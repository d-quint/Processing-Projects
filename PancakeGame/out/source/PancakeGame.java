/* autogenerated by Processing revision 1293 on 2023-12-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PancakeGame extends PApplet {

final int SKY_BLUE = color(195, 238, 250);
final int PASTEL_RED = color(220, 180, 200);

final int PANCAKE_COLOR = color(228, 207, 172);
final int PANCAKE_OUTLINE = color(205, 174, 119);

final int PLAYER_COLOR = color(255);

final float PLAYER_WIDTH = 100;
final float PANCAKE_WIDTH = 110;

Pan player;
Pancake cakes;
FallingPancakes fallingCakes;

// ----------------------------------------------------------

public void setup() {
  /* size commented out by preprocessor */;
  loadPixels();
  player = new Pan(PLAYER_WIDTH);
  cakes = new Pancake(player, PANCAKE_WIDTH);
  fallingCakes = new FallingPancakes(5);
}

public void draw() {
  fillGradient(SKY_BLUE, PASTEL_RED);
  player.update();
  cakes.update();
  fallingCakes.update();
}

public void mousePressed() {
  cakes.addChild();
  fallingCakes.addPancake();
}

// ----------------------------------------------------------

public void fillGradient(int c1, int c2) {
  /*
  *  This function draws a vertical linear gradient
  *  (from top to bottom) with the given two colors.
  */
  
  for (int y = 0; y < height; y++) {
    float percent = (float) y / height;
    int c = lerpColor(c1, c2, percent);
    
    for (int x = 0; x < width; x++) {
      pixels[y * width + x] = c;
    }
  }
  
  updatePixels();
}
class FallingPancake {
  final PVector ACC = new PVector(0.f, 0.98f);
  final float CAKE_RADIUS = PANCAKE_WIDTH * 0.5f;
  final float BELOW_HEIGHT = 50.f;

  PVector pos, vel;

  FallingPancake() {
    this.pos = new PVector(random(width), random(-1000, 0));
    this.vel = new PVector(random(0, 5), random(0, 5));
  }

  FallingPancake(PVector pos, PVector vel) {
    this.pos = pos;
    this.vel = vel;
  }

  public void update() {
    move();
    render();
  }
  
  private void move() {
    this.vel = vel.add(ACC);
    this.pos = pos.add(vel);

    if (pos.y >= height + BELOW_HEIGHT) {
      this.pos = new PVector(random(width), random(-1000, 0));
      this.vel = new PVector(random(0, 5), random(0, 5));
    }
  }
  
  private void render() {
    pushMatrix();
    
    translate(pos.x, pos.y);
    fill(PANCAKE_COLOR);
    strokeWeight(2.5f);
    stroke(PANCAKE_OUTLINE);
    ellipseMode(RADIUS);
    ellipse(0.f, 0.f, CAKE_RADIUS, CAKE_RADIUS);
    
    popMatrix();
  }
}
class FallingPancakes {
  ArrayList<FallingPancake> fallingPancakes;

  FallingPancakes(int numOfPancakes) {
    fallingPancakes = new ArrayList<FallingPancake>();

    for (int i = 0; i < numOfPancakes; i++) {
      fallingPancakes.add(new FallingPancake());
    }
  }

  public void update() {
    if (fallingPancakes.size() == 0) {
      return;
    }

    for (FallingPancake pancake : fallingPancakes) {
      pancake.update();
    }
  }

  public void addPancake() {
    fallingPancakes.add(new FallingPancake());
  }
}
final int OFFSET = 50;
final float EASING_FACTOR = 0.925f;

class Pan {
  float bodyWidth, thickness;
  PVector pos, target;
  
  Pancake head;
  
  Pan(float bodyWidth) {
    this.bodyWidth = bodyWidth;
    this.thickness = 20.0f;
    
    this.pos = new PVector(width * 0.5f, height - OFFSET);
    this.target = new PVector(mouseX, mouseY);
  }
  
  public void update() {
    move();
    render();
  }
  
  public PVector getPos() {
    return this.pos;
  }
  
  public float getThickness() {
    return this.thickness;
  }
  
  private void move() {
    float halfWidth = bodyWidth * 0.5f;
    target = new PVector(mouseX, mouseY);
    
    // If a side touches an edge and the target isn't inward, don't move any further
    if (pos.x - halfWidth <= 0) {
      if (target.x - pos.x <= 0) {
        pos.x = halfWidth;
        return;
      }
    } else if (pos.x + halfWidth >= width) {
      if (target.x - pos.x >= 0) {
        pos.x = width - halfWidth;
        return;
      }
    }
    
    pos.x = lerp(target.x, pos.x, EASING_FACTOR);
  }
  
  private void render() {
    pushMatrix();
    
    translate(pos.x, pos.y);
    fill(PLAYER_COLOR);
    noStroke();
    rectMode(CENTER);
    rect(0, 0, bodyWidth, thickness, 5);
    
    popMatrix();
  }
}
final float PANCAKE_EASING_FACTOR = 0.25f;

class Pancake {
  float bodyWidth, thickness;
  PVector pos, target;
  
  Pancake parent, child;
  Pan plate;
  
  Pancake(Pan plate, float bodyWidth) {
    this.plate = plate;
    
    this.bodyWidth = bodyWidth;
    this.thickness = 15.0f;
    
    float totalOffset = OFFSET + ((plate.getThickness() + this.thickness) * 0.5f);
    
    this.pos = new PVector(width * 0.5f, height - totalOffset);
    this.target = new PVector(mouseX, mouseY);
    
    this.parent = this.child = null;
  }
  
  public void addChild() {
    if (child == null) {
      this.child = new Pancake(plate, bodyWidth + 2.0f);
      this.child.setParent(this);
    } else {
      child.addChild();
    }
  }
  
  public void setParent(Pancake parent) {
    this.parent = parent;
    this.pos.y = this.parent.getPos().y - thickness;
  }
  
  public PVector getPos() {
    return this.pos; 
  }
  
  public void update() {
    move();
    render();
    
    if (child != null) {
      child.update();
    }
  }
  
  private void move() {
    float halfWidth = bodyWidth * 0.5f;
    target = (parent != null ? parent.getPos() : plate.getPos());
    
    // If a side touches an edge and the target isn't inward, don't move any further
    if (pos.x - halfWidth <= 0) {
      if (target.x - pos.x <= 0) {
        pos.x = halfWidth;
        return;
      }
    } else if (pos.x + halfWidth >= width) {
      if (target.x - pos.x >= 0) {
        pos.x = width - halfWidth;
        return;
      }
    }
    
    pos.x = lerp(target.x, pos.x, PANCAKE_EASING_FACTOR);
  }
  
  private void render() {
    pushMatrix();
    
    translate(pos.x, pos.y);
    fill(PANCAKE_COLOR);
    strokeWeight(2.5f);
    stroke(PANCAKE_OUTLINE);
    rectMode(CENTER);
    rect(0, 0, bodyWidth, thickness, 10);
    
    popMatrix();
  }
}


  public void settings() { size(1000, 600, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PancakeGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
