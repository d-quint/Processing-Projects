/* autogenerated by Processing revision 1293 on 2023-09-02 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PancakeGame extends PApplet {

final int SKY_BLUE = color(195, 238, 250);
final int PASTEL_RED = color(220, 180, 200);

final int PANCAKE_COLOR = color(247,215,136);

final float PLAYER_WIDTH = 100;
final float PANCAKE_WIDTH = 110;

Pan player;
Pancake cakes;

// ----------------------------------------------------------

public void setup() {
    /* size commented out by preprocessor */;
    loadPixels();
    player = new Pan(PLAYER_WIDTH);
    cakes = new Pancake(player, PANCAKE_WIDTH);
}

public void draw() {
    fillGradient(SKY_BLUE, PASTEL_RED);
    player.update();
    cakes.update();
}

public void mousePressed() {
    cakes.addChild();
}

// ----------------------------------------------------------

public void fillGradient(int c1, int c2) {
    /* 
     *  This function draws a vertical linear gradient
     *  (from top to bottom) with the given two colors.
     */

    for (int y = 0; y < height; y++) {
        float percent = (float) y / height;
        int c = lerpColor(c1, c2, percent);

        for (int x = 0; x < width; x++) {
            pixels[y * width + x] = c;
        }
    }

    updatePixels();
}
final int OFFSET = 50;
final float EASING_FACTOR = 0.925f;

class Pan {
    float bodyWidth, thickness;
    PVector pos, target;

    Pancake head;

    Pan(float bodyWidth) {
        this.bodyWidth = bodyWidth;
        this.thickness = 20.0f;

        this.pos = new PVector(width * 0.5f, height - OFFSET);
        this.target = new PVector(mouseX, mouseY);
    }

    public void update() {
        move();
        render();
    }

    public PVector getPos() {
        return this.pos;
    }

    public float getThickness() {
        return this.thickness;
    }

    private void move() {
        float halfWidth = bodyWidth * 0.5f;
        target = new PVector(mouseX, mouseY);
        
        // If a side touches an edge and the target isn't inward, don't move any further
        if (pos.x - halfWidth <= 0) {
            if (target.x - pos.x <= 0) {
                pos.x = halfWidth;
                return;
            }
        } else if (pos.x + halfWidth >= width) {
            if (target.x - pos.x >= 0) {
                pos.x = width - halfWidth;
                return;
            }
        }

        pos.x = lerp(target.x, pos.x, EASING_FACTOR);
    }

    private void render() {
        pushMatrix();

        translate(pos.x, pos.y);
        fill(255);
        noStroke();
        rectMode(CENTER);
        rect(0, 0, bodyWidth, thickness, 5);

        popMatrix();
    }
}
final float PANCAKE_EASING_FACTOR = 0.95f;

class Pancake {
    float bodyWidth, thickness;
    PVector pos, target;

    Pancake parent, child;
    Pan plate;

    Pancake(Pan plate, float bodyWidth) {
        this.plate = plate;

        this.bodyWidth = bodyWidth;
        this.thickness = 15.0f;

        float totalOffset = OFFSET + ((plate.getThickness() + this.thickness) * 0.5f);

        this.pos = new PVector(width * 0.5f, height - totalOffset);
        this.target = new PVector(mouseX, mouseY);

        this.parent = this.child = null;
    }

    public void addChild() {
        if (child == null) {
            this.child = new Pancake(plate, bodyWidth + 2.0f);
            this.child.setParent(this);
        } else {
            child.addChild();
        }
    }

    public void setParent(Pancake parent) {
        this.parent = parent;
        this.pos.y = this.parent.getPos().y - thickness;
    }

    public PVector getPos() {
        return this.pos; 
    }

    public void update() {
        move();
        render();

        if (child != null) {
            child.update();
        }
    }

    private void move() {
        if (parent == null) {
            target = plate.getPos();
        } else {
            target = parent.getPos();
        }
            
        float halfWidth = bodyWidth * 0.5f;
        
        // If a side touches an edge and the target isn't inward, don't move any further
        if (pos.x - halfWidth <= 0) {
            if (target.x - pos.x <= 0) {
                pos.x = halfWidth;
                return;
            }
        } else if (pos.x + halfWidth >= width) {
            if (target.x - pos.x >= 0) {
                pos.x = width - halfWidth;
                return;
            }
        }

        pos.x = lerp(target.x, pos.x, PANCAKE_EASING_FACTOR);
    }

    private void render() {
        pushMatrix();

        translate(pos.x, pos.y);
        fill(PANCAKE_COLOR);
        stroke(0);
        rectMode(CENTER);
        rect(0, 0, bodyWidth, thickness, 10);

        popMatrix();
    }
}


  public void settings() { size(1000, 600, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PancakeGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
