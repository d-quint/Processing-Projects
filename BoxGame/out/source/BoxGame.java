/* autogenerated by Processing revision 1293 on 2023-08-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class BoxGame extends PApplet {



SoundFile sfx_sweep, sfx_win, sfx_tap, sfx_bgm;

final int GRID_SIZE = 60;
final float EASING_FACTOR = 0.2f;

int numRows, numCols;
BoxManager boxManager;

public void setup() {
  /* size commented out by preprocessor */;
  numRows = height / GRID_SIZE;
  numCols = width / GRID_SIZE;
  boxManager = new BoxManager();
  
  loadSfx();
}

public void draw() {
  background(240);
  drawGrid();
  boxManager.updatePositions();
  boxManager.display();
}

public void mousePressed() {
  sfx_tap.play();

  if (mouseButton == LEFT)
    boxManager.addBox(new Box(mouseX / GRID_SIZE, mouseY / GRID_SIZE));
    
  if (mouseButton == RIGHT)
    boxManager.addWall(new Wall(mouseX / GRID_SIZE, mouseY / GRID_SIZE));
    
  if (mouseButton == CENTER)
    boxManager.addTarget(new Target(mouseX / GRID_SIZE, mouseY / GRID_SIZE));
}

public void drawGrid() {
  stroke(200);
  for (int row = 0; row < numRows; row++) {
    for (int col = 0; col < numCols; col++) {
      float x = col * GRID_SIZE;
      float y = row * GRID_SIZE;
      noFill();
      rect(x, y, GRID_SIZE, GRID_SIZE);
    }
  }
}

public void keyPressed() {
  if (keyCode == UP || keyCode == DOWN || keyCode == LEFT || keyCode == RIGHT) {
    boxManager.setTargetPositions(keyCode);
  }
}

public void loadSfx() {
  sfx_sweep = new SoundFile(this, "assets/sfx/sweep.wav");
  sfx_win = new SoundFile(this, "assets/sfx/win.wav");
  sfx_tap = new SoundFile(this, "assets/sfx/tap.wav");
  sfx_bgm = new SoundFile(this, "assets/sfx/level_music.mp3");

  sfx_bgm.loop();
}
class Box {
  int col, row;
  int bodyColor;
  
  float x, y;
  float targetX, targetY;
  
  boolean isAnimating;

  Box(int col, int row) {
    this.col = col;
    this.row = row;
    
    this.x = col * GRID_SIZE;
    this.y = row * GRID_SIZE;
    
    this.targetX = this.x;
    this.targetY = this.y;
    
    this.isAnimating = false;
    this.bodyColor = color(0, 150, 200);
  }
  
  public int getCol() {
    return col;
  }
  
  public int getRow() {
    return row;
  }

  public void setTargetPosition(int col, int row) {
    if (!isAnimating) {
      this.col = col;
      this.row = row;
      
      this.targetX = col * GRID_SIZE;
      this.targetY = row * GRID_SIZE;
      
      this.isAnimating = true;
    }
  }

  public void updatePosition() {
    if (isAnimating) {
      float dx = targetX - x;
      float dy = targetY - y;
      x += dx * EASING_FACTOR;
      y += dy * EASING_FACTOR;

      // Check if the animation is finished
      if (abs(dx) < 1 && abs(dy) < 1) {
        x = targetX;
        y = targetY;
        
        isAnimating = false;
      }
    }
  }
  
  public void inTarget() {
    // To be implemented
  }

  public void display() {
    pushMatrix();
    noStroke();
    fill(bodyColor);
    rect(x, y, GRID_SIZE, GRID_SIZE, 20);
    popMatrix();
  }
}
class BoxManager {
  ArrayList<Box> boxes;
  ArrayList<Wall> walls;
  ArrayList<Target> targets;
  
  boolean isAnimating;

  BoxManager() {
    boxes = new ArrayList<Box>();
    walls = new ArrayList<Wall>();
    targets = new ArrayList<Target>();
    
    isAnimating = false;
  }

  public void addBox(Box box) {
    boxes.add(box);
  }
  
  public void addWall(Wall wall) {
    walls.add(wall);
  }
  
  public void addTarget(Target target) {
    targets.add(target);
  }

  public void setTargetPositions(int keyCode) {
    if (!isAnimating) {
      boolean wasValid = false;
      isAnimating = true;

      for (Box box : boxes) {
        int newRow = box.row;
        int newCol = box.col;

        if (keyCode == UP) {
          newRow--;
        } else if (keyCode == DOWN) {
          newRow++;
        } else if (keyCode == LEFT) {
          newCol--;
        } else if (keyCode == RIGHT) {
          newCol++;
        }

        // If the target tile is valid, move the box there
        if (isValidPosition(newRow, newCol, box)) {
          box.setTargetPosition(newCol, newRow);
          wasValid = true;
        }
      }
      
      if (wasValid) {
        sfx_sweep.play();
      } else {
        sfx_tap.play(); 
      }
      
      // If all boxes are in targets, the game is finished
      if (checkGameState()) {
        gameFinish();
      }
    }
  }
  
  public boolean checkGameState() {
    if (targets.size() != boxes.size()) {
      return false;
    }
    
    int count = 0; // Counts how many boxes are in targets
    
    for (Box box : boxes) {
      for (Target target : targets) {
        if (box.getRow() == target.getRow() && box.getCol() == target.getCol()) {
          count++;
          box.inTarget();
          break;
        }
      }
    }
    
    return count == targets.size(); 
  }

  public void updatePositions() {
    boolean allFinished = true;
    
    for (Box box : boxes) {
      box.updatePosition();

      // If any box is still animating, it is not finished
      if (box.isAnimating) {
        allFinished = false;
      }
    }
    
    if (allFinished) {
      isAnimating = false;
    }
  }

  public void display() {
    for (Box box : boxes) {
      box.display();
    }
    for (Wall wall : walls) {
      wall.display();
    }
    for (Target target : targets) {
      target.display();
    }
  }

  public boolean isValidPosition(int row, int col, Box box) {
    // Recursively check if adjacent boxes can move in the same direction
    for (Box nextBox : boxes) {
      if (nextBox.getCol() == col && nextBox.getRow() == row) {
        if (box.getCol() == nextBox.getCol() && box.getRow() < nextBox.getRow()) {
          return isValidPosition(row + 1, col, nextBox);
        } else if (box.getCol() == nextBox.getCol() && box.getRow() > nextBox.getRow()) {
          return isValidPosition(row - 1, col, nextBox);
        } else if (box.getRow() == nextBox.getRow() && box.getCol() < nextBox.getCol()) {
          return isValidPosition(row, col + 1, nextBox);
        } else if (box.getRow() == nextBox.getRow() && box.getCol() > nextBox.getCol()) {
          return isValidPosition(row, col - 1, nextBox);
        } 
      }
    }
    
    // Check for adjacent walls
    for (Wall wall : walls) {
      if (wall.getCol() == col && wall.getRow() == row) {
        return false;
      }
    }
    
    // Check for boundary
    return row >= 0 && row < numRows && col >= 0 && col < numCols;
  }
  
  public void gameFinish() {
    sfx_bgm.stop();
    sfx_win.play();
    println("Game finished!");
  }
}
class Target extends Wall {
   Target(int col, int row) {
      super(col, row);
   }
   
   @Override public 
   void display() {
     fill(201, 230, 192, 200);
     rect(x, y, GRID_SIZE, GRID_SIZE);
   }
}
class Wall {
  int col, row;
  float x, y;

  Wall(int col, int row) {
    this.col = col;
    this.row = row;
    
    this.x = col * GRID_SIZE;
    this.y = row * GRID_SIZE;
  }
  
  public int getCol() {
    return col;
  }
  
  public int getRow() {
    return row;
  }
  
  public void display() {
    fill(220, 150, 200);
    rect(x, y, GRID_SIZE, GRID_SIZE);
  }
}


  public void settings() { size(600, 600, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "BoxGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
